/*
ID: bdsomme1
LANG: JAVA
TASK: snail
*/
import java.io.*;
import java.util.*;

class snail{
	public static void main (String[] args) throws IOException {
		BufferedReader f = new BufferedReader(new FileReader("snail.in"));
    PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter("snail.out")));
		
		StringTokenizer reader = new StringTokenizer(f.readLine());
		int size = Integer.parseInt(reader.nextToken());
		int bars = Integer.parseInt(reader.nextToken());
		int[] board = new int[size * size];
		int[][][] barriers = new int[2][size][size];
		for(int i = 0; i < bars; i++)
		{
			String line = f.readLine();
			int row = Integer.parseInt(line.substring(1)) - 1;
			int col = line.charAt(0)-65;
			board[row * size + col] = 1;
			barriers[0][row][barriers[0][row][0] + 1] = col;
			barriers[1][col][barriers[1][col][0] + 1] = row;
			barriers[0][row][0]++;
			barriers[1][col][0]++;
		}
		board[0] = 5;
		flood(board, 0, 0, 0, barriers, size);
		flood(board, 0, 0, 3, barriers, size);
		
		out.println(algorithm(board, size));
		
		
		
		out.close();
	}
	
	public static boolean possible (int[] board, int size, int row, int col, int direction)
	{
		int[] copy = (int[]) board.clone();
		if(direction == 0)
		{
			int previous = 0;
			for(int c = col+1; c < size; c++)
			{
				if(board[row*size + c] == 1)
				{
					break;
				}
				previous = board[row*size+c];
				board[row*size+c] = 2;
				
				
				
			}
		}
		else if (direction == 2)
		{
		
		}
		else if (direction == 1)
		{
		
		}
		else
		{
		
		}
		
		
		
		
	}
	
	public static int recursive (int row, int col, int[] board, int size, int direction, int ud, int lr, int traveled)
	{
		if(row == 0 && col == 0)
			return traveled;
		if(row == 0 && (ud == 2 || lr == 2 || lr == 1) && direction == 0)
			return 0;
		if(row == size-1 && (ud == 1 || lr == 2) && direction == 0)
			return 0;
		if(col == size-1 && (lr == 1 || ud == 2) && direction == 3)
			return 0;
		if(col == 0 && (lr == 2 || ud == 1 || ud == 2) && direction == 3)
			return 0;
		if(col == size-1 && ud == 1 && direction == 1)
			return 0;
		if(row == size-1 && lr == 1 && direction == 2)
			return 0;
		
		
		if(col == size-1)
		{
			lr = 2;
		}
		else if (col == 0)
		{
			lr = 1;
		}
		if(row == 0)
		{
			ud = 1;
		}
		else if (row == size-1)
		{
			ud = 2;
		}
		
		int max = 0;
		int[] copy = (int[]) board.clone();
		if(direction == 0)
		{
			for(int c = col + 1; c < size; c++)
			{
				if(board[row * size + c] == 1 || board[row*size + c] == 2)
				{
					break;
				}
				
				copy[row*size + c] = 2;
				if((row == 0 || copy[(row-1) * size + c] == 1))
						{
							int save = recursive(row, c, copy, size, 3, ud, lr, c-col+traveled);
							if(save > max)
							{
								max = save;
							}
						}
						else if((row == size-1 || copy[(row+1) * size + c] == 1))
						{
							int save = recursive(row, c, copy, size, 1, ud, lr, c-col+traveled);
							if(save > max)
							{
								max = save;
							}
						}
			}
		}
		else if (direction == 1)
		{
			for(int r = row - 1; r >= 0; r--)
			{
				if(board[r * size + col] == 1 || board[r*size + col] == 2)
				{
					break;
				}
				
				copy[r*size + col] = 2;
				if((col == 0 || copy[r * size + col-1] == 1))
						{
							int save = recursive(r, col, copy, size, 0, ud, lr, row-r+traveled);
							if(save > max)
							{
								max = save;
							}
						}
						else if((col == size-1 || copy[r * size + col+1] == 1))
						{
							int save = recursive(r, col, copy, size, 2, ud, lr, row-r+traveled);
							if(save > max)
							{
								max = save;
							}
						}
			}
		}
		else if (direction == 2)
		{
			for(int c = col - 1; c >= 0; c--)
			{
				if(board[row * size + c] == 1 || board[row*size + c] == 2)
				{
					break;
				}
				
				copy[row*size + c] = 2;
				if((row == 0 || copy[(row-1) * size + c] == 1))
						{
							int save = recursive(row, c, copy, size, 3, ud, lr, col-c+traveled);
							if(save > max)
							{
								max = save;
							}
						}
						else if((row == size-1 || copy[(row+1) * size + c] == 1))
						{
							int save = recursive(row, c, copy, size, 1, ud, lr, col-c+traveled);
							if(save > max)
							{
								max = save;
							}
						}
			}
		}
		else
		{
			for(int r = row + 1; r < size; r++)
			{
				if(board[r * size + col] == 1 || board[r*size + col] == 2)
				{
					break;
				}
				
				copy[r*size + col] = 2;
				if((col == 0 || copy[r * size + col-1] == 1))
						{
							int save = recursive(r, col, copy, size, 0, ud, lr, r-row+traveled);
							if(save > max)
							{
								max = save;
							}
						}
						else if((col == size-1 || copy[r * size + col+1] == 1))
						{
							int save = recursive(r, col, copy, size, 2, ud, lr, r-row+traveled);
							if(save > max)
							{
								max = save;
							}
						}
			}
		}
		
		return max;
	}
	
	public static int algorithm (int[] board, int size)
	{
		int max = 1;
		
		for(int i = 0; i < size*size; i++)
		{
			int row = i / size;
			int col = i % size;
			if(board[i] == 5)
			{
				if(row != 0 && row != size-1 && col != size-1)
				{
					//right
					int[] copy = (int[]) board.clone();
					for(int c = col + 1; c < size; c++)
					{
						
						if(copy[row * size + c] == 1)
						{
							break;
						}
						
						copy[row*size + c] = 2;
						if((row == 0 || copy[(row-1) * size + c] == 1))
						{
							int save = recursive(row, c, copy, size, 3, 0, 0, c-col);
							if(save > max)
							{
								max = save;
							}
						}
						else if((row == size-1 || copy[(row+1) * size + c] == 1))
						{
							int save = recursive(row, c, copy, size, 1, 0, 0, c-col);
							if(save > max)
							{
								max = save;
							
							}
						}
					}
				}
				if(row != 0 && row != size-1 && col != 0)
				{
					//left
					int[] copy = (int[]) board.clone();
					for(int c = col - 1; c >= 0; c--)
					{
						
						if(copy[row * size + c] == 1)
						{
							break;
						}
						
						copy[row*size + c] = 2;
						if((row == 0 || copy[(row-1) * size + c] == 1))
						{
							int save = recursive(row, c, copy, size, 3, 0, 0, col-c);
							if(save > max)
							{
								max = save;
							}
						}
						else if((row == size-1 || copy[(row+1) * size + c] == 1))
						{
							int save = recursive(row, c, copy, size, 1, 0, 0, col-c);
							if(save > max)
							{
								max = save;
							}
						}
					}
				}
				if(col != 0 && col != size-1 && row != 0)
				{
					//up
					int[] copy = (int[]) board.clone();
					
					for(int r = row - 1; r >= 0; r--)
					{
						
						if(copy[r * size + col] == 1)
						{
							break;
						}
						
						copy[r*size + col] = 2;
						if((col == 0 || copy[r * size + col-1] == 1))
						{
							int save = recursive(r, col, copy, size, 0, 0, 0, row-r);
							if(save > max)
							{
								max = save;
							}
						}
						else if((col == size-1 || copy[r * size + col+1] == 1))
						{
							int save = recursive(r, col, copy, size, 2, 0, 0, row-r);
							if(save > max)
							{
								max = save;
							}
						}
					}
				}
				if(col != 0 && col != size-1 && row != size-1)
				{
					//down
					int[] copy = (int[]) board.clone();
					
					for(int r = row + 1; r < size; r++)
					{
						
						if(copy[r * size + col] == 1)
						{
							break;
						}
				
						copy[r*size + col] = 2;
						if((col == 0 || copy[r * size + col-1] == 1))
						{
							int save = recursive(r, col, copy, size, 0, 0, 0, r-row);
							if(save > max)
							{
								max = save;
							}
						}
						else if((col == size-1 || copy[r * size + col+1] == 1))
						{
							int save = recursive(r, col, copy, size, 2, 0, 0, r - row);
							if(save > max)
							{
								max = save;
							}
						}
					}
				}
			}
			else if ((row == 0 || board[i-size] == 1) && (row == size-1 || board[i+size] == 1) && (col == 0 || board[i-1] == 1))
			{
				//right
					int[] copy = (int[]) board.clone();
					int left = 0;
					if(col == 0)
					{
						left = 1;
					}
					for(int c = col + 1; c < size; c++)
					{
						
						if(copy[row * size + c] == 1)
						{
							break;
						}
						
						copy[row*size + c] = 2;
						if((row == 0 || copy[(row-1) * size + c] == 1))
						{
							int save = recursive(row, c, copy, size, 3, 0, left, c-col+1);
							if(save > max)
							{
								max = save;
							}
						}
						else if((row == size-1 || copy[(row+1) * size + c] == 1))
						{
							int save = recursive(row, c, copy, size, 1, 0, left, c-col+1);
							if(save > max)
							{
								max = save;
							}
						}
					}
			}
			else if ((row == 0 || board[i-size] == 1) && (row == size-1 || board[i+size] == 1) && (col == size-1 || board[i+1] == 1))
			{
				//left
					int[] copy = (int[]) board.clone();
					int left = 0;
					if(col == size-1)
					{
						left = 2;
					}
					for(int c = col - 1; c >= 0; c--)
					{
						
						if(copy[row * size + c] == 1)
						{
							break;
						}
						
						copy[row*size + c] = 2;
						if((row == 0 || copy[(row-1) * size + c] == 1))
						{
							int save = recursive(row, c, copy, size, 3, 0, left, col-c+1);
							if(save > max)
							{
								max = save;
							}
						}
						else if((row == size-1 || copy[(row+1) * size + c] == 1))
						{
							int save = recursive(row, c, copy, size, 1, 0, left, col-c+1);
							if(save > max)
							{
								max = save;
							}
						}
					}
			}
			else if ((col == 0 || board[i-1] == 1) && (col == size-1 || board[i+1] == 1) && (row == size-1 || board[i+size] == 1))
			{
				//up
				int[] copy = (int[]) board.clone();
					int up = 0;
					if(row == size-1)
					{
						up = 2;
					}
					for(int r = row - 1; r >= 0; r--)
					{
						
						if(copy[r * size + col] == 1)
						{
							break;
						}
						
						copy[r*size + col] = 2;
						if((col == 0 || copy[r * size + col-1] == 1))
						{
							int save = recursive(r, col, copy, size, 0, up, 0, row-r+1);
							if(save > max)
							{
								max = save;
							}
						}
						else if((col == size-1 || copy[r * size + col+1] == 1))
						{
							int save = recursive(r, col, copy, size, 2, up, 0, row-r+1);
							if(save > max)
							{
								max = save;
							}
						}
					}
			}
			else if ((col == 0 || board[i-1] == 1) && (col == size-1 || board[i+1] == 1) && (row == 0 || board[i-size] == 1))
			{
				//down
				int[] copy = (int[]) board.clone();
					int up = 0;
					if(row == 0)
					{
						up = 1;
					}
					for(int r = row + 1; r < size; r++)
					{
						
						if(copy[r * size + col] == 1)
						{
							break;
						}
						
						copy[r*size + col] = 2;
						if((col == 0 || copy[r * size + col-1] == 1))
						{
							int save = recursive(r, col, copy, size, 0, up, 0, r-row+1);
							if(save > max)
							{
								max = save;
							}
						}
						else if((col == size-1 || copy[r * size + col+1] == 1))
						{
							int save = recursive(r, col, copy, size, 2, up, 0, r - row+1);
							if(save > max)
							{
								max = save;
							}
						}
					}
			}
		}
		
		
		
		return max;
	}
	
	public static void flood (int[] board, int row, int col, int direction, int[][][] barriers, int size)
	{
		if(direction == 0)
		{
			int bar = size;
			for(int i = 1; i <= barriers[0][row][0]; i++)
			{
				if(barriers[0][row][i] > col)
				{
					bar = barriers[0][row][i];
					break;
				}
			}
			int visited = board[row * size + bar - 1];
			for(int c = col + 1; c < bar; c++)
			{
				if(board[row * size + c] != 4)
				{
					board[row * size + c] = 3;
				}
				else
				{
					board[row * size + c] = 5;
				}
			}
			
			if(visited == 0)
			{
				int p = 0;
				if(row != 0 && board[(row-1) * size + bar-1] != 1)
				{
					flood(board, row, bar-1, 1, barriers, size);
					p++;
				}
				if(row != size - 1 && board[(row+1) * size + bar-1] != 1)
				{
					flood(board, row, bar-1, 3, barriers, size);
					p++;
				}
				if(p == 2)
				{
					board[row * size + bar-1] = 5;
				}
			}
		}
		else if (direction == 2)
		{
			int bar = -1;
			for(int i = barriers[0][row][0]; i > 0 ; i--)
			{
				if(barriers[0][row][i] < col)
				{
					bar = barriers[0][row][i];
					break;
				}
			}
			int visited = board[row * size + bar + 1];
			for(int c = col - 1; c > bar; c--)
			{
				if(board[row * size + c] != 4)
				{
					board[row * size + c] = 3;
				}
				else
				{
					board[row * size + c] = 5;
				}
			}
			
			if(visited == 0)
			{
				int p = 0;
				if(row != 0 && board[(row-1) * size + bar+1] != 1)
				{
					flood(board, row, bar+1, 1, barriers, size);
					p++;
				}
				if(row != size - 1 && board[(row+1) * size + bar+1] != 1)
				{
					flood(board, row, bar+1, 3, barriers, size);
					p++;
				}
				if(p == 2)
				{
					board[row * size + bar + 1] = 5;
				}
			}
		}
		else if (direction == 1)
		{
			int bar = -1;
			for(int i = barriers[1][col][0]; i > 0; i--)
			{
				if(barriers[1][col][i] < row)
				{
					bar = barriers[1][col][i];
					break;
				}
			}
			int visited = board[(bar + 1) * size + col];
			for(int r = row-1; r > bar; r--)
			{
				if(board[r * size + col] != 3)
				{
					board[r * size + col] = 4;
				}
				else
				{
					board[r * size + col] = 5;
				}
			}
			if(visited == 0)
			{
				int p = 0;
				if(col != 0 && board[(bar+1) * size + col-1] != 1)
				{
					flood(board, bar+1, col, 2, barriers, size);
					p++;
				}
				if(col != size-1 && board[(bar+1) * size + col+1] != 1)
				{
					flood(board, bar+1, col, 0, barriers, size);
					p++;
				}
				if(p == 2)
				{
					board[(bar+1) * size + col] = 5;
				}
			}
		}
		else
		{
			int bar = size;
			for(int i = 1; i <= barriers[1][col][0]; i++)
			{
				if(barriers[1][col][i] > row)
				{
					bar = barriers[1][col][i];
					break;
				}
			}
			int visited = board[(bar - 1) * size + col];
			for(int r = row+1; r < bar; r++)
			{
				if(board[r * size + col] != 3)
				{
					board[r * size + col] = 4;
				}
				else
				{
					board[r * size + col] = 5;
				}
			}
			if(visited == 0)
			{
				int p = 0;
				if(col != 0 && board[(bar-1) * size + col-1] != 1)
				{
					flood(board, bar-1, col, 2, barriers, size);
					p++;
				}
				if(col != size-1 && board[(bar-1) * size + col+1] != 1)
				{
					flood(board, bar-1, col, 0, barriers, size);
					p++;
				}
				if(p == 2)
				{
					board[(bar-1) * size + col] = 5;
				}
			}
		}
	}
	
}